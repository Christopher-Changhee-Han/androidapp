lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test$response - lm.pred)^2) #MSE
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, rating)
source("cleandata.R")
calculateMSE <- function(dataset, response, features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
lmdata <- lm(response~., data= train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test$response - lm.pred)^2) #MSE
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
#read in and clean the data to be ready for analysis
googleData <- read.csv("googleplaystore.csv", stringsAsFactors = FALSE)
googleData <- cleandata(googleData)
#test few different models, and see which fits best
##run initial linear model
fullmodel <- lm(rating~ ., data = googleData)
summary(fullmodel)
##check some conditions
residFitted(fullmodel)
vif(fullmodel)
##check results
Anova(fullmodel, type = "III")
fullMSE <- calculateMSE(googleData, rating)
debug(calculateMSE)
fullMSE <- calculateMSE(googleData, rating)
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
str(response)
str(train$response)
train$response
View(train)
as.character(response)
calculateMSE <- function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
lmdata <- lm(response~., data= train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test$response - lm.pred)^2) #MSE
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, rating)
fullMSE <- calculateMSE(googleData, "rating")
debug(calculateMSE)
fullMSE <- calculateMSE(googleData, "rating")
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
lmdata <- lm(response~., data= train)
View(train)
View(dataset)
View(googleData)
sum(complete.cases(googleData))
lmdata <- lm(response~., data= train)
length(train$category)
length(train$rating)
train$response
as.character(response)
calculateMSE <- function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
lmdata <- lm(as.character(response)~., data= train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test$response - lm.pred)^2) #MSE
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, "rating")
debug(calculateMSE)
fullMSE <- calculateMSE(googleData, "rating")
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
lmdata <- lm(as.character(response)~., data= train)
train$as.character(response)
train$(as.character(response)(
train$(as.character(response))
a <- as.character(response)
calculateMSE <- function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
if (features == "."){
lmdata <- lm(train[,names(train) == response] ~.)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test[,names(test) == response] - lm.pred)^2) #MSE
}
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, "rating")
calculateMSE <- function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
if (features == "."){
lmdata <- lm(train[,names(train) == response] ~., data = train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test[,names(test) == response] - lm.pred)^2) #MSE
}
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, "rating")
calculateMSE <- function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
#set unused levels of installs to NA
id <- which(!(test$installs %in% levels(train$installs)))
test$installs[id] <- NA
if (features == "."){
lmdata <- lm(train[,names(train) == response] ~., data = train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test[,names(test) == response] - lm.pred)^2) #MSE
}
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, "rating")
debug(calculateMSE)
fullMSE <- calculateMSE(googleData, "rating")
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
#set unused levels of installs to NA
id <- which(!(test$installs %in% levels(train$installs)))
levels(train$installs)
test$installs[id] <- NA
if (features == "."){
lmdata <- lm(train[,names(train) == response] ~., data = train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test[,names(test) == response] - lm.pred)^2) #MSE
}
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
#set unused levels of installs to NA
id <- which(!(test$installs %in% levels(train$installs)))
test$installs[id] <- NA
function (formula, data, subset, weights, na.action, method = "qr",
model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
contrasts = NULL, offset, ...)
{
ret.x <- x
ret.y <- y
cl <- match.call()
mf <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data", "subset", "weights", "na.action",
"offset"), names(mf), 0L)
mf <- mf[c(1L, m)]
mf$drop.unused.levels <- TRUE
mf[[1L]] <- quote(stats::model.frame)
mf <- eval(mf, parent.frame())
if (method == "model.frame")
return(mf)
else if (method != "qr")
warning(gettextf("method = '%s' is not supported. Using 'qr'",
method), domain = NA)
mt <- attr(mf, "terms")
y <- model.response(mf, "numeric")
w <- as.vector(model.weights(mf))
if (!is.null(w) && !is.numeric(w))
stop("'weights' must be a numeric vector")
offset <- as.vector(model.offset(mf))
if (!is.null(offset)) {
if (length(offset) != NROW(y))
stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
length(offset), NROW(y)), domain = NA)
}
if (is.empty.model(mt)) {
x <- NULL
z <- list(coefficients = if (is.matrix(y)) matrix(,
0, 3) else numeric(), residuals = y, fitted.values = 0 *
y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
0) else if (is.matrix(y)) nrow(y) else length(y))
if (!is.null(offset)) {
z$fitted.values <- offset
z$residuals <- y - offset
}
}
else {
x <- model.matrix(mt, mf, contrasts)
z <- if (is.null(w))
lm.fit(x, y, offset = offset, singular.ok = singular.ok,
...)
else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
...)
}
class(z) <- c(if (is.matrix(y)) "mlm", "lm")
z$na.action <- attr(mf, "na.action")
z$offset <- offset
z$contrasts <- attr(x, "contrasts")
z$xlevels <- .getXlevels(mt, mf)
z$call <- cl
z$terms <- mt
if (model)
z$model <- mf
if (ret.x)
z$x <- x
if (ret.y)
z$y <- y
if (!qr)
z$qr <- NULL
z
}
function (definition = sys.function(sys.parent()), call = sys.call(sys.parent()),
expand.dots = TRUE, envir = parent.frame(2L))
{
if (!missing(definition) && is.null(definition)) {
definition <- sys.function(sys.parent())
}
.Internal(match.call(definition, call, expand.dots, envir))
}
function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
#set unused levels of installs to NA
id <- which(!(test$installs %in% levels(train$installs)))
test$installs[id] <- NA
if (features == "."){
lmdata <- lm(train[,names(train) == response] ~., data = train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test[,names(test) == response] - lm.pred)^2) #MSE
}
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), nrow(dataset)/3)
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
#set unused levels of installs to NA
id <- which(!(test$installs %in% levels(train$installs)))
test$installs[id] <- NA
View(lmdata)
View(train)
calculateMSE <- function(dataset, response = "", features = ".", seed = 201){
set.seed(seed)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(dataset), 2*(nrow(dataset)/3))
train <- dataset[twothirds,]
test <- dataset[-twothirds,]
#set unused levels of installs to NA
id <- which(!(test$installs %in% levels(train$installs)))
test$installs[id] <- NA
if (features == "."){
lmdata <- lm(train[,names(train) == response] ~., data = train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test[,names(test) == response] - lm.pred)^2) #MSE
}
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(response~ features, data=dataset)
cv.error10[d]=cv.glm(dataset,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
}
fullMSE <- calculateMSE(googleData, "rating")
debug(calculateMSE)
fullMSE <- calculateMSE(googleData, "rating")
View(lmdata)
test[,names(test) == response]
(test[,names(test) == response] - lm.pred)
results <- vector(length = 2, mode = "numeric")
set.seed(201)
set.seed(201)
results <- vector(length = 2, mode = "numeric")
twothirds = sample(1:nrow(googleData), 2*(nrow(googleData)/3))
test <- googleData[-twothirds,]
#set unused levels of installs to NA
#id <- which(!(test$installs %in% levels(train$installs)))
#test$installs[id] <- NA
lmdata <- lm(rating ~., data = train)
train <- googleData[twothirds,]
test <- googleData[-twothirds,]
#set unused levels of installs to NA
#id <- which(!(test$installs %in% levels(train$installs)))
#test$installs[id] <- NA
lmdata <- lm(rating ~., data = train)
lm.pred = predict(lmdata, test, type = "response")
results[1] <- mean((test$rating- lm.pred)^2) #MSE
#what about cross validation error?
cv.error10=rep(0,5)
degree= 1:5
d=1
for(d in degree){
glm.fit=glm(rating~ ., data=googleData)
cv.error10[d]=cv.glm(googleData,glm.fit,K=10)$delta[1]
}
results[2] <- cv.error10/5
results
results[2] <- (cv.error10)/5
results[2] <- mean(cv.error10)
results
results <- setNames(c(1, 2), c("MSE", "c.v MSE"))
results <- setNames(c(0, 0), c("MSE", "c.v MSE"))
results[1] <- mean((test$rating- lm.pred)^2) #MSE
results[2] <- mean(cv.error10)
results #0.
testerrors[1] <- results #0.
#divde data frame into two separate parts
lessthanfour <- filter(newData, rating < 4)
newData <- select(googleData, c("category", "rating", "installs", "type", "lastupdated", "androidver"))
#divde data frame into two separate parts
lessthanfour <- filter(newData, rating < 4)
View(lessthanfour)
morethanfour <- filter(newData, rating >=4)
#let's run linear models on these two
#linear model less than four
lmltf <- lm(rating~., data = lessthanfour)
summary(lmltf)
Anova(lmltf, type = "III")
#linear model more than four
lmmtf <- lm(rating~., data = morethanfour)
summary(lmmtf)
Anova(lmmtf, type = "III")
Anova(lmltf, type = "III")
knitr::opts_chunk$set(echo = TRUE)
```{r, message=FALSE}
#install.packages("devtools") #if needed
#devtools::install_github("MichaelJMahometa/SDSRegressionR", force = TRUE)
library(dplyr)
library(lubridate)
library(car)
library(SDSRegressionR)
library(boot)
source("cleandata.R")
#category seems to be significant
?par
#category seems to be significant
par(mfrow=2, mfcol= 3)
#category seems to be significant
par(mfrow=c(2,3))
plot(rating~category, data = googleData)
#so does the number of installs
plot(rating~installs, data = googleData)
plot(rating~ reviews, data = googleData) # hard to see, try using only upto 3rd quartile
with(googleData[googleData$reviews < summary(googleData$reviews)[[5]],], plot(rating ~ reviews))
#lets try running a linear model just with reviews
lmreview <- lm(rating~ reviews, data = googleData[googleData$reviews < summary(googleData$reviews)[[5]],])
residFitted(lmreview)
Anova(lmmtf, type = "III")
par(mfrow=c(2,3))
plot(rating~category, data = lessthanfour)
plot(rating~installs, data = lessthanfour)
plot(rating~type, data = lessthanfour)
plot(rating~lastupdated, data = lessthanfour)
plot(rating~androidver, data = lessthanfour)
par(mfrow=c(2,3))
plot(rating~category, data = morethanfour)
plot(rating~installs, data = morethanfour)
plot(rating~type, data = morethanfour)
plot(rating~lastupdated, data = morethanfour)
plot(rating~androidver, data = morethanfour)
Anova(lmmtf, type = "III")
residualPlot(lmmtf)
mtext(“Rating < 4.0”, outer = TRUE, cex = 1.5)
?mtext
mtext("Rating < 4.0", outer = TRUE, cex = 1.5)
mtext("Rating < 4.0", side = 3, outer = TRUE, cex = 1.5)
par(mfrow=c(2,3))
plot(rating~category, data = lessthanfour)
plot(rating~installs, data = lessthanfour)
plot(rating~type, data = lessthanfour)
plot(rating~lastupdated, data = lessthanfour)
plot(rating~androidver, data = lessthanfour)
mtext("Rating < 4.0", side = 3, outer = TRUE, cex = 1.5)
residualPlot(lmltf)
mtext("Rating < 4.0", side = 3, line=1, outer = TRUE, cex = 1.5)
?mtext
mtext("Rating < 4.0", side = 3, cex = 1.5)
mtext("Rating < 4.0", side = 3, line = 1, cex = 1.5)
par(mfrow=c(2,3))
mtext("Rating < 4.0", side = 3, line = 1, cex = 1.5)
plot(rating~category, data = lessthanfour)
mtext("Rating < 4.0", side = 3, line = 1, cex = 1.5)
title("Centered Overall Title", outer=TRUE)
plot(rating~category, data = lessthanfour)
plot(rating~installs, data = lessthanfour)
plot(rating~type, data = lessthanfour)
par(mfrow=c(2,3))
plot(rating~category, data = lessthanfour)
plot(rating~installs, data = lessthanfour)
plot(rating~type, data = lessthanfour)
plot(rating~lastupdated, data = lessthanfour)
plot(rating~androidver, data = lessthanfour)
residualPlot(lmltf)
title("Centered Overall Title", outer=TRUE)
?title
title("Centered Overall Title", outer=TRUE, line = 1)
title("Centered Overall Title", outer=TRUE, line = -2)
title("Centered Overall Title", outer=TRUE, line = -3)
par(mfrow=c(2,3))
plot(rating~category, data = lessthanfour)
plot(rating~installs, data = lessthanfour)
plot(rating~type, data = lessthanfour)
plot(rating~lastupdated, data = lessthanfour)
plot(rating~androidver, data = lessthanfour)
residualPlot(lmltf)
title("Rating < 4.0", outer=TRUE, line = -2)
#read in and clean the data to be ready for analysis
googleData <- read.csv("googleplaystore.csv", stringsAsFactors = FALSE)
View(googleData)
sum(googleData$Current.Ver == "Varies with device")
1459/10841
install.packages("rmarkdown")
library("rmarkdown", lib.loc="~/R/win-library/3.5")
